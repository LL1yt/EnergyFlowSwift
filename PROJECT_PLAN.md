# PROJECT_PLAN.md: 3D Клеточная Нейронная Сеть

## Обзор Проекта

### Основная Идея (Простыми Словами)

Представьте себе 3D решетку из одинаковых "умных клеток" (как клетки в живой ткани). Каждая клетка:

- Получает сигналы от соседних клеток
- Обрабатывает эти сигналы по одним и тем же правилам
- Передает результат дальше соседям
- Все клетки работают одновременно (параллельно)

**Аналогия с биологией**: Как в нервной ткани - одинаковые нейроны, организованные в структуру, где каждый получает сигналы от соседей и передает дальше.

### Техническая Суть

- **Вход**: Эмбединг подается на одну грань 3D куба
- **Обработка**: Сигнал распространяется через решетку маленьких нейросетей
- **Выход**: Результат считывается с противоположной грани и декодируется в токены
- **Обучение**: Учим только ОДИН прототип клетки + декодер (очень эффективно!)

## Философия Разработки

### Ключевые Принципы для Новичка

1. **Один Шаг = Один Тест**: После каждого маленького изменения проверяем, что все работает
2. **Понятные Названия**: Все переменные и функции называем так, чтобы было ясно, что они делают
3. **Много Комментариев**: Объясняем не только "что", но и "зачем"
4. **Визуализация**: На каждом этапе смотрим, что происходит (графики, принты)
5. **Маленькие Модули**: Каждый кусочек кода делает только одну простую вещь

## Структура Проекта (Модули)

### Уровень 1: Базовые Компоненты

```
cellular-neural-network/
├── core/                          # Основные компоненты
│   ├── cell-prototype/           # Один "умный" блок
│   ├── lattice-3d/              # 3D решетка из блоков
│   └── signal-propagation/       # Как сигнал идет по решетке
├── data/                         # Работа с данными
│   ├── embedding-loader/         # Загрузка входных эмбедингов
│   ├── tokenizer/               # Превращение текста в числа и обратно
│   └── data-visualization/       # Показываем, что происходит
├── training/                     # Обучение системы
│   ├── loss-calculator/         # Считаем, насколько ошиблись
│   ├── optimizer/               # Улучшаем веса сети
│   └── training-loop/           # Процесс обучения
├── inference/                    # Использование обученной сети
│   ├── decoder/                 # Превращаем выход сети в токены
│   └── prediction/              # Делаем предсказания
├── utils/                       # Вспомогательные инструменты
│   ├── config-manager/          # Настройки системы
│   ├── logger/                  # Записываем, что происходит
│   └── math-helpers/            # Простые математические функции
└── examples/                    # Примеры использования
    ├── simple-2d-demo/          # Простая 2D версия для понимания
    └── full-3d-system/          # Полная 3D система
```

## Поэтапный План Реализации

### Фаза 1: Понимание и Подготовка (Дни 1-3)

#### Шаг 1.1: Настройка Окружения

- [ ] Создать основную структуру папок
- [ ] Установить необходимые библиотеки (PyTorch, NumPy, Matplotlib)
- [ ] Создать конфигурационный файл с базовыми настройками
- [ ] **ТЕСТ**: Запустить простой скрипт, чтобы убедиться, что все библиотеки работают

#### Шаг 1.2: Создание Документации

- [ ] README.md для каждого модуля
- [ ] plan.md с детальными шагами
- [ ] meta.md с описанием зависимостей
- [ ] diagram.mmd с визуальными схемами
- [ ] **ТЕСТ**: Прочитать документацию и убедиться, что все понятно

### Фаза 2: Простейший Прототип (Дни 4-7)

#### Шаг 2.1: Создание Одной "Умной Клетки" (cell-prototype)

**Цель**: Сделать один блок, который принимает числа и выдает другие числа

**Что делаем**:

- Создаем класс CellPrototype с простейшей архитектурой (1 слой + активация)
- Добавляем входы для: состояния соседей + собственное состояние + внешний вход
- **ТЕСТ**: Подаем случайные числа, смотрим, что выходит

```python
# Примерная структура (будет в модуле cell-prototype)
class CellPrototype:
    """Один 'умный' блок - основа всей системы"""
    def __init__(self, input_size, state_size):
        # Инициализация весов
        pass

    def forward(self, neighbor_states, own_state, external_input):
        # Обработка входов и возврат нового состояния
        pass
```

#### Шаг 2.2: Создание Маленькой 2D Решетки (simple-2d-demo)

**Цель**: Понять, как клетки общаются друг с другом

**Что делаем**:

- Создаем сетку 3x3 или 5x5 из наших клеток
- Каждая клетка знает только о своих соседях (сверху, снизу, слева, справа)
- **ТЕСТ**: Подаем сигнал в один угол, смотрим, как он распространяется

#### Шаг 2.3: Визуализация Процесса (data-visualization)

**Цель**: Видеть, что происходит в системе

**Что делаем**:

- Функции для отображения состояния решетки в виде цветной картинки
- Анимация распространения сигнала по времени
- **ТЕСТ**: Запускаем и видим красивые картинки

### Фаза 3: Базовая Функциональность (Дни 8-14)

#### Шаг 3.1: Расширение до 3D (lattice-3d)

**Цель**: Перейти от плоской сетки к объемной

**Что делаем**:

- Модифицируем код для работы с 3D координатами
- Добавляем соседей по третьему измерению (глубина)
- **ТЕСТ**: Создаем маленький куб 3x3x3, проверяем связи

#### Шаг 3.2: Система Распространения Сигналов (signal-propagation)

**Цель**: Управлять тем, как информация движется по решетке

**Что делаем**:

- Функция для одного шага времени (все клетки обновляются одновременно)
- Цикл по времени (несколько шагов подряд)
- **ТЕСТ**: Сигнал от одной стороны куба доходит до другой

#### Шаг 3.3: Загрузка Данных (embedding-loader)

**Цель**: Подавать реальные эмбединги на вход системы

**Что делаем**:

- Функции для загрузки простых векторов (например, из файла)
- Преобразование вектора в формат для подачи на грань куба
- **ТЕСТ**: Загружаем тестовый вектор, подаем в систему

### Фаза 4: Обучение Системы (Дни 15-21)

#### Шаг 4.1: Декодер Выходных Сигналов (decoder)

**Цель**: Превращать состояние выходной грани в понятные токены

**Что делаем**:

- Простая нейросеть, которая читает состояния клеток и выдает вероятности токенов
- **ТЕСТ**: Подаем случайные состояния, получаем случайные токены

#### Шаг 4.2: Функция Потерь (loss-calculator)

**Цель**: Измерять, насколько хорошо система справляется с задачей

**Что делаем**:

- Сравниваем предсказанные токены с правильными ответами
- **ТЕСТ**: Специально даем неправильный ответ, убеждаемся, что потери большие

#### Шаг 4.3: Процесс Обучения (training-loop)

**Цель**: Автоматически улучшать веса системы

**Что делаем**:

- Цикл: подать данные → получить предсказание → посчитать ошибку → обновить веса
- **ТЕСТ**: После нескольких итераций ошибка должна уменьшаться

### Фаза 5: Полная Система (Дни 22-30)

#### Шаг 5.1: Интеграция Всех Модулей (main.py)

**Цель**: Собрать все части в единую работающую систему

**Что делаем**:

- Главный скрипт, который использует все модули
- Конфигурационные файлы для разных экспериментов
- **ТЕСТ**: Полный цикл от входного эмбединга до выходных токенов

#### Шаг 5.2: Эксперименты и Оптимизация

**Цель**: Понять, как настроить систему для лучшей работы

**Что делаем**:

- Тестируем разные размеры решетки
- Пробуем разные архитектуры клеток
- **ТЕСТ**: Сравниваем качество на простой задаче

#### Шаг 5.3: Документация и Примеры

**Цель**: Сделать проект понятным для других

**Что делаем**:

- Детальное описание всех компонентов
- Примеры использования
- Объяснение биологических аналогий

## Критерии Готовности

### Минимально Работающая Версия (MVP)

- [ ] 3D решетка 5x5x5 клеток
- [ ] Сигнал проходит от входной грани к выходной
- [ ] Система может быть обучена на простых данных
- [ ] Есть визуализация процесса

### Полная Версия

- [ ] Решетка произвольного размера
- [ ] Несколько архитектур клеток на выбор
- [ ] Обучение на реальных эмбедингах
- [ ] Подробная документация и примеры

## Управление Рисками

### Основные Сложности и Решения

1. **Математическая Сложность**
   - **Риск**: Формулы могут показаться страшными
   - **Решение**: Каждую формулу объясняем простыми словами и аналогиями
2. **Нестабильность Обучения**

   - **Риск**: Система может "взорваться" или "затухнуть"
   - **Решение**: Начинаем с очень простых случаев, добавляем ограничения

3. **Производительность**

   - **Риск**: Большие 3D решетки могут работать медленно
   - **Решение**: Начинаем с маленьких размеров, оптимизируем постепенно

4. **Отладка**
   - **Риск**: Сложно понять, где ошибка
   - **Решение**: Много визуализации и логирования на каждом шаге

## Ресурсы и Зависимости

### Технические Требования

- Python 3.8+
- PyTorch (для нейросетей)
- NumPy (для математики)
- Matplotlib (для графиков)
- Jupyter Notebook (для экспериментов)

### Обучающие Материалы

- Документация PyTorch (с примерами)
- Статьи о клеточных автоматах
- Видео о распространении сигналов в нейросетях

### Временные Рамки

- **Всего**: 30 дней
- **MVP**: 14 дней
- **Полная версия**: 30 дней
- **Время на день**: 2-4 часа

## Критерии Успеха

### Технические

- [ ] Система обучается без ошибок
- [ ] Качество предсказаний лучше случайного
- [ ] Код работает на решетках разного размера

### Образовательные

- [ ] Все концепции понятны без глубоких знаний программирования
- [ ] Каждый модуль можно изучить и понять отдельно
- [ ] Есть наглядная демонстрация всех процессов

### Исследовательские

- [ ] Можно легко экспериментировать с разными параметрами
- [ ] Система показывает интересное поведение
- [ ] Результаты можно воспроизвести

## Следующие Шаги

1. **Начать с Фазы 1**: Настроить окружение и создать базовую документацию
2. **Создать первый модуль**: cell-prototype с простейшей функциональностью
3. **Протестировать каждый шаг**: Убедиться, что понимаем, что происходит
4. **Документировать процесс**: Записывать все наблюдения и решения

---

**Помните**: Это исследовательский проект. Главная цель - понять концепцию и получить работающий прототип. Не стремитесь к идеальной производительности с первого раза!
