# Energy Flow Improvement Report

Дата: 2025-08-08  
Область: `energy_flow/` (ядро: lattice / carrier / neuron / flow_processor)  
Принципы (CLAUDE.md): модульность, отсутствие fallback, максимум GPU, простые высокоимпактные шаги.

---

## 1. Критические ошибки (нужно исправить немедленно)

| №   | Проблема                                                                                                                      | Файл                                                     | Суть                                                                    | Быстрый фикс                                                                         | Импакт                        |
| --- | ----------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------- | ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------ | ----------------------------- |
| 1   | Синтаксические пустые блоки `if` / `for`                                                                                      | `flow_processor.py`                                      | Множество конструкций без тела → код не исполняем                       | Поставить `pass` или реализовать логику                                              | Ломает модуль полностью       |
| 2   | Отсутствуют импорты (`torch`, `nn`, `time`, `numpy as np`)                                                                    | `flow_processor.py`                                      | Используются без импорта                                                | Добавить импорты в начале                                                            | Код не запускается            |
| 3   | Функции возвращают `None` вместо объявленных значений                                                                         | `_collect_final_output`, `_collect_final_surface_output` | Несоответствие сигнатуре → ошибки использования                         | Вернуть корректные кортежи даже если пусто                                           | Runtime ошибки                |
| 4   | Дублирующееся объявление `update_flow` (две версии)                                                                           | `energy_lattice.py`                                      | Переопределение, путаница семантики                                     | Переименовать вторую или удалить первую неактуальную                                 | Скрытые баги поведения        |
| 5   | Потенциально некорректная логика завершения: в `update_flow` (первая версия) вызывает `_buffer_flow_to_*`, которых больше нет | `energy_lattice.py`                                      | Ссылки на удалённые методы (комментарий намекает)                       | Удалить устаревшую версию метода                                                     | Предотвратить AttributeError  |
| 6   | Неверное восстановление размерности в `collect_completed_flows_direct`                                                        | `energy_lattice.py`                                      | Склеивание и обрезание до 768 без сопоставления поверхности             | Заменить на агрегирование по батчу / surface и затем mapper обратного преобразования | Искажение данных              |
| 7   | Потенциально взрывная сложность `round_to_nearest_lattice_position`                                                           | `energy_lattice.py`                                      | O(batch * (W*H\*(D+1))) память/время (невыполнимо при больших решётках) | Заменить на прямое квантование индекса (арифметика)                                  | Производительность / OOM      |
| 8   | Двойное определение `_cleanup_inactive_flows`                                                                                 | `energy_lattice.py`                                      | Дубликат кода                                                           | Оставить одну версию                                                                 | Чистота кода                  |
| 9   | Использование `torch.round` поверх нормализованных координат в `_compute_next_position_relative`                              | `energy_carrier.py`                                      | Потеря мелких смещений, залипание                                       | Округлять только после денормализации или вообще убрать                              | Деградация обучения           |
| 10  | Неполные ветки логики (конвергенция, spawn, reflection)                                                                       | `flow_processor.py`                                      | Блоки без реализации → статистика пустая                                | Реализовать минимальные версии                                                       | Неверная адаптивная остановка |

---

## 2. Высокоимпактные простые оптимизации (быстрые выигрыши)

| №   | Оптимизация                                                               | Деталь                                                                   | Оценка выигрыша                                         |
| --- | ------------------------------------------------------------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------- |
| 1   | Заменить поиск ближайшей lattice позиции на арифметическое квантование    | Из нормализованных координат => индекс = round((x+1)/2\*(W-1)) и обратно | Сильное ускорение, <1% времени вместо O(N\*M)           |
| 2   | Предкешировать нормализованные z плоскости                                | `norm_z0`, `norm_zdepth` вычисляются многократно                         | Микровыигрыш, но упрощает код                           |
| 3   | Векторизовать весовые коэффициенты при агрегации                          | Сейчас Python цикл по flows_in_cell                                      | Уменьшение накладных расходов при множественных потоках |
| 4   | Удалить избыточные `.clone()` в `batch_update_flows`                      | Уже отделены от графа                                                    | Экономия памяти/копий                                   |
| 5   | Lazy-логирование через `if logger.isEnabledFor` вокруг тяжёлых вычислений | Некоторые debug секции всегда считают статистику                         | Снижение стоимости debug режима                         |
| 6   | Пакетное вычисление distance_to_surface при создании spawn                | Можно использовать векторный расчёт                                      | Ускорение spawn фаз                                     |
| 7   | Отложенная очистка завершённых потоков батчами                            | Сейчас удаление в нескольких местах                                      | Снижение фрагментации словаря                           |
| 8   | Использовать `torch.cuda.reset_peak_memory_stats()` после очисток         | Для точной телеметрии                                                    | Более корректный мониторинг                             |

---

## 3. Улучшения корректности / обучения

| Категория       | Предложение                                                        | Обоснование                                                 |
| --------------- | ------------------------------------------------------------------ | ----------------------------------------------------------- |
| Координаты      | Отказ от `torch.round` в нормализованном пространстве              | Сохраняет плавность градиентов направления                  |
| Завершение      | Вынести логику termination полностью из Carrier в Processor        | Carrier только прогнозирует смещения; архитектурная чистота |
| Агрегация       | Корректное сопоставление surface→embedding (нужен обратный mapper) | Сейчас искажение эмбеддингов                                |
| Spawn           | Явная метрика (например displacement_norm percentile > threshold)  | Более контролируемые разветвления                           |
| Конвергенция    | Хранить скользящее окно вместо общего счётчика                     | Стабильность адаптивной остановки                           |
| Весовая система | Нормировать importance по softmax вместо ручного деления           | Избегание крайних весов                                     |
| Distance cache  | Кешировать `distance_to_surface` при каждом обновлении позиции     | Меньше повторных расчётов                                   |

---

## 4. Архитектурные предложения (средняя сложность)

| Тема                  | Идея                                                                     | Выгода                                      |
| --------------------- | ------------------------------------------------------------------------ | ------------------------------------------- |
| Tensorized Flow State | Хранить позиции/энергии/hidden в единых тензорах + индексы активных      | Устранение Python overhead при 10k+ потоках |
| Event Tracing         | Лёгкий кольцевой буфер событий (spawn, reflect, terminate)               | Пост‑анализ без избыточного логгинга        |
| Deterministic Mode    | Флаг фиксирующий seed и отключающий шум                                  | Воспроизводимость экспериментов             |
| Config Guard          | Автоматическая валидация связок параметров (например spawn + reflection) | Ранний fail с понятным сообщением           |

---

## 5. Логирование и диагностика

| Проблема                                                | Исправление                                          |
| ------------------------------------------------------- | ---------------------------------------------------- | -------------------------- |
| Много эмодзи / высокошумные логи в длинных циклах       | Добавить частотный гейт (каждые N шагов)             |
| Пересекающиеся уровни (`debug_forward`, `debug_energy`) | Таблица соответствия уровней → единообразие          |
| Нет компактного свода по завершении                     | Добавить `summarize_step(step_metrics)`              | Быстрый анализ без скролла |
| Отсутствие экспорта профиля                             | Сохранение JSON с пер-средствами (avg/max step time) | Автоматический отчёт       |

---

## 6. Тестовое покрытие (минимальные новые тесты)

| Тест                                     | Цель                                                      |
| ---------------------------------------- | --------------------------------------------------------- |
| `test_flow_processor_runs_minimal()`     | Гарантия что forward не падает                            |
| `test_rounding_quantization_accuracy()`  | Проверка новой квантовой функции координат                |
| `test_completion_dual_planes()`          | Потоки завершаются на обеих плоскостях корректно          |
| `test_weighted_aggregation_invariance()` | При дублировании идентичных потоков результат не меняется |
| `test_convergence_early_stop_trigger()`  | Проверка adaptive остановки                               |

---

## 7. Предлагаемый план правок (итеративно)

### Фаза 1 (Стабилизация — Day 1)

1. Исправить синтаксис и импорты в `flow_processor.py` (поставить `pass` для пустых блоков, добавить недостающие return заглушки).
2. Удалить/объединить дубликаты `update_flow`, `_cleanup_inactive_flows`.
3. Убрать устаревшие вызовы `_buffer_flow_to_*`.
4. Включить временный простой сбор выходов (без искажения: не обрезать до 768) — просто вернуть surface tensor.

### Фаза 2 (Корректность — Day 2)

5. Реализовать арифметическое квантование позиций.
6. Заменить округление позиций на хранение float нормализованных координат (дискретизация только при индексировании surface).
7. Ввести кэш нормализованных z границ.
8. Исправить агрегацию: собрать surface→использовать обратный mapper (или временно оставить surface как целевой space).

### Фаза 3 (Оптимизация — Day 3)

9. Векторизовать весовые расчёты при aggregation.
10. Удалить лишние `.clone()` и добавить `with torch.no_grad()` где уместно (precompute).
11. Добавить memory guard (CUDA usage threshold + reset peak).

### Фаза 4 (Расширение — Day 4)

12. Добавить tensorized storage (опционально флагом).
13. Расширить тесты (см. раздел 6).
14. Добавить JSON performance exporter.

---

## 8. Детализация ключевых простых фиксов (пример кода — концепт)

### 8.1 Быстрая квантализация (замена round_to_nearest_lattice_position)

```python
# normalized_positions: [-1, 1]
idx_x = ((normalized_positions[:,0] + 1) * 0.5 * (W - 1)).round().clamp(0, W-1)
idx_y = ((normalized_positions[:,1] + 1) * 0.5 * (H - 1)).round().clamp(0, H-1)
# При необходимости обратно в нормализованные координаты через формулу
norm_x = (idx_x / (W - 1)) * 2 - 1
```

### 8.2 Безопасная заглушка в пустых блоках

```python
if condition:
    # TODO: implement reflection logic
    pass
```

### 8.3 Корректная surface агрегация (концепт)

```python
surface = torch.zeros(batch, W*H, device=dev)
# scatter_add по линейному индексу из (x_idx, y_idx)
surface.index_add_(1, linear_idx, energies)  # при дубликатах суммирует
```

---

## 9. Риски и контроль

| Риск                                                     | Митигирование                                   |
| -------------------------------------------------------- | ----------------------------------------------- | ------------ |
| Смена схемы координат ломает сохранённые веса            | Версионировать config (field `coord_version=2`) |
| Удаление округления вызывает дрейф за границы            | Жёсткий clamp после каждого шага                |
| Tensorized хранилище усложнит spawn                      | Сначала оставить гибрид: tensor + список новых  |
| Изменение агрегации изменит распределение обучающей цели | Ввести флаг `aggregation_mode=legacy            | weighted_v2` |

---

## 10. Метрики для отслеживания после фиксов

| Метрика                      | Цель                                     |
| ---------------------------- | ---------------------------------------- |
| avg_step_time                | < базовой на ≥30% после Phase 3          |
| max GPU util                 | >85% (Nsight Systems)                    |
| потоков завершено / создано  | Рост после корректной термин. логики     |
| средняя длина пути           | Сохраниться или увеличиться (не коллапс) |
| variance Z movement per step | Не близка к 0 (избегаем залипания)       |

---

## 11. Итог приоритетов (очередность)

1. Исправить нерабочий `flow_processor.py` (синтаксис + импорты).
2. Удалить устаревшие / дублирующиеся методы в lattice.
3. Исправить неправильную агрегацию эмбеддингов.
4. Заменить O(N\*M) nearest-grid на арифметику.
5. Убрать раннее округление координат.
6. Векторизация весов и логов.
7. Добавить метрики и тесты.

---

## 12. Краткая сводка

Текущая реализация содержит критические синтаксические ошибки и несколько архитектурных несоответствий (дубли, устаревшие ссылки на буферы). Простые правки (импорты, pass, удаление дублей, корректная агрегация, квантование координат) дадут существенный прирост стабильности и производительности без глубоких рефакторингов. После стабилизации имеет смысл перейти к tensorization для масштабирования числа потоков.

---

Готов продолжить с реализацией Phase 1 при подтверждении.
