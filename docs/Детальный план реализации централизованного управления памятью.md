–û—Å–Ω–æ–≤—ã–≤–∞—è—Å—å –Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –≤–∞—à–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ –∏ –ø–æ–¥—Ö–æ–¥–µ –∫ —Ä–µ—à–µ–Ω–∏—é –∑–∞–¥–∞—á, –≤—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –ø–æ—Ö–æ–∂–∏ –Ω–∞ —Ñ–∏–∑–∏–∫–∞ –∏–ª–∏ –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—è –≤ –æ–±–ª–∞—Å—Ç–∏ computational neuroscience (–¥–æ—Å—Ç–æ–≤–µ—Ä–Ω–æ—Å—Ç—å ‚âà 85%). –í–æ—Ç –ø–æ—á–µ–º—É:

## üìä –ü—Ä–∏–∑–Ω–∞–∫–∏ —Ñ–∏–∑–∏–∫–∞/–∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—è:

1. **–§–æ–∫—É—Å –Ω–∞ –Ω–∞—É—á–Ω–æ–π –∑–∞–¥–∞—á–µ**: 3D Cellular Neural Network —Å –±–∏–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–º–∏ –ø—Ä–∏–Ω—Ü–∏–ø–∞–º–∏
2. **–≠–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π –ø–æ–¥—Ö–æ–¥**: "—É–¥–∞—á–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–æ–≤"
3. **–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏ –Ω–∞–¥ –ø–µ—Ä—Ñ–µ–∫—Ü–∏–æ–Ω–∏–∑–º–æ–º**: —Ç–∏–ø–∏—á–Ω–æ –¥–ª—è –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –∫–æ–¥–∞
4. **–°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∞—è —Ç–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏—è**: emergence, plasticity, biological correctness

## üéØ –†–µ–∞–ª–∏—Å—Ç–∏—á–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ —É—Å–ø–µ—Ö–∞

### –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –∑–∞–ø—É—Ç–∞—Ç—å—Å—è: **70-80%**

–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–π –ø–ª–∞–Ω —Å–ª–∏—à–∫–æ–º –∞–º–±–∏—Ü–∏–æ–∑–µ–Ω –¥–ª—è –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—è, –∏—Å–ø–æ–ª—å–∑—É—é—â–µ–≥–æ Claude Code. –û—Å–Ω–æ–≤–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã:

1. **–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–π** - 7 —Ñ–∞–∑, –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Å–æ–≤
2. **–°–ª–æ–∂–Ω–∞—è –∏–µ—Ä–∞—Ä—Ö–∏—è** - IMemoryPool, MemoryManagedModule, –∞–¥–∞–ø—Ç–µ—Ä—ã
3. **–ù–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞** –≤—Å–µ–≥–æ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∫–æ–¥–∞

### –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —É—Å–ø–µ—Ö–∞ —Å —Ç–µ–∫—É—â–∏–º –ø–ª–∞–Ω–æ–º: **20-30%**

## üí° –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ –¥–ª—è —Ñ–∏–∑–∏–∫–∞

–í–º–µ—Å—Ç–æ —Å–ª–æ–∂–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã, –ø—Ä–µ–¥–ª–∞–≥–∞—é **–º–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ**:

### –í–∞—Ä–∏–∞–Ω—Ç 1: –ü—Ä–æ—Å—Ç–æ–π –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ø—É–ª (2-3 –¥–Ω—è)

```python
# new_rebuild/core/memory/simple_pool.py

class SimpleMemoryPool:
    """–ü—Ä–æ—Å—Ç–æ–π –ø—É–ª –ø–∞–º—è—Ç–∏ - –º–∏–Ω–∏–º—É–º —Å–ª–æ–∂–Ω–æ—Å—Ç–∏, –º–∞–∫—Å–∏–º—É–º –ø–æ–ª—å–∑—ã"""

    def __init__(self):
        self.pools = {}  # {shape: [tensor1, tensor2, ...]}
        self.device = get_device_manager().get_device()

    def get_tensor(self, shape, dtype=torch.float32):
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–Ω–∑–æ—Ä –Ω—É–∂–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞"""
        key = (shape, dtype)

        # –ï—Å—Ç—å –≤ –ø—É–ª–µ? –ë–µ—Ä–µ–º
        if key in self.pools and self.pools[key]:
            return self.pools[key].pop().zero_()

        # –ù–µ—Ç? –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π
        return torch.zeros(shape, dtype=dtype, device=self.device)

    def return_tensor(self, tensor):
        """–í–µ—Ä–Ω—É—Ç—å —Ç–µ–Ω–∑–æ—Ä –≤ –ø—É–ª"""
        if tensor is None:
            return

        key = (tuple(tensor.shape), tensor.dtype)
        if key not in self.pools:
            self.pools[key] = []

        # –•—Ä–∞–Ω–∏–º –º–∞–∫—Å–∏–º—É–º 10 —Ç–µ–Ω–∑–æ—Ä–æ–≤ –∫–∞–∂–¥–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
        if len(self.pools[key]) < 10:
            self.pools[key].append(tensor.detach())

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
memory_pool = SimpleMemoryPool()
```

### –í–∞—Ä–∏–∞–Ω—Ç 2: –î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è (1 –¥–µ–Ω—å)

```python
# new_rebuild/core/memory/auto_memory.py

def managed_memory(func):
    """–î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–∞–º—è—Ç—å—é"""
    def wrapper(self, *args, **kwargs):
        # –°–ø–∏—Å–æ–∫ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö —Ç–µ–Ω–∑–æ—Ä–æ–≤
        created_tensors = []

        # –ü–æ–¥–º–µ–Ω—è–µ–º torch.zeros/empty –Ω–∞ –Ω–∞—à–∏ –≤–µ—Ä—Å–∏–∏
        original_zeros = torch.zeros
        original_empty = torch.empty

        def tracked_zeros(*args, **kwargs):
            tensor = memory_pool.get_tensor(args[0], kwargs.get('dtype', torch.float32))
            created_tensors.append(tensor)
            return tensor

        torch.zeros = tracked_zeros
        torch.empty = tracked_zeros

        try:
            # –í—ã–ø–æ–ª–Ω—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é
            result = func(self, *args, **kwargs)
            return result
        finally:
            # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
            torch.zeros = original_zeros
            torch.empty = original_empty

            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ–Ω–∑–æ—Ä—ã –≤ –ø—É–ª
            for tensor in created_tensors:
                memory_pool.return_tensor(tensor)

    return wrapper
```

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:

```python
class MoEProcessor(nn.Module):
    @managed_memory
    def forward_single_cell(self, ...):
        # –í–µ—Å—å –∫–æ–¥ –æ—Å—Ç–∞–µ—Ç—Å—è –∫–∞–∫ –µ—Å—Ç—å!
        # torch.zeros –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø—É–ª
        distant_output = torch.zeros((1, self.state_size))
        ...
```

### –í–∞—Ä–∏–∞–Ω—Ç 3: –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä (—Å–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π)

```python
# new_rebuild/core/memory/context_pool.py

class MemoryContext:
    """–ö–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ —Ç–µ–Ω–∑–æ—Ä–∞–º–∏"""

    def __init__(self):
        self.tensors = []

    def zeros(self, *args, **kwargs):
        """–°–æ–∑–¥–∞—Ç—å —É–ø—Ä–∞–≤–ª—è–µ–º—ã–π —Ç–µ–Ω–∑–æ—Ä"""
        tensor = memory_pool.get_tensor(args[0], kwargs.get('dtype', torch.float32))
        self.tensors.append(tensor)
        return tensor

    def __enter__(self):
        return self

    def __exit__(self, *args):
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Å–µ –≤ –ø—É–ª
        for tensor in self.tensors:
            memory_pool.return_tensor(tensor)
```

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:

```python
def process_cell(cell_idx, state):
    with MemoryContext() as mem:
        # –í–º–µ—Å—Ç–æ torch.zeros –∏—Å–ø–æ–ª—å–∑—É–µ–º mem.zeros
        temp1 = mem.zeros((100, 32))
        temp2 = mem.zeros((50, 64))
        # ... –≤—ã—á–∏—Å–ª–µ–Ω–∏—è ...
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
```

## üéØ –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π –ø–ª–∞–Ω –¥–ª—è —Ñ–∏–∑–∏–∫–∞

### –ù–µ–¥–µ–ª—è 1: –ü—Ä–æ—Å—Ç–æ–π –ø—É–ª (80% –≤—ã–≥–æ–¥—ã)

1. –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å `SimpleMemoryPool`
2. –î–æ–±–∞–≤–∏—Ç—å –≤ 3-4 —Å–∞–º—ã—Ö "–≥–æ—Ä—è—á–∏—Ö" –º–µ—Å—Ç–∞
3. –ò–∑–º–µ—Ä–∏—Ç—å —É–ª—É—á—à–µ–Ω–∏–µ

### –ù–µ–¥–µ–ª—è 2: –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)

1. –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ—Å—Ç—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
2. –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å –≤ –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –º–æ–¥—É–ª–∏
3. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å —Ä–∞–∑–º–µ—Ä—ã –ø—É–ª–æ–≤

### –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥

```python
def print_memory_stats():
    """–ü—Ä–æ—Å—Ç–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏"""
    total_pooled = sum(len(tensors) for tensors in memory_pool.pools.values())
    total_size_mb = sum(
        len(tensors) * np.prod(shape) * 4 / 1024**2  # float32 = 4 bytes
        for (shape, dtype), tensors in memory_pool.pools.items()
    )
    print(f"Pooled tensors: {total_pooled}, Size: {total_size_mb:.1f}MB")
```

## ‚úÖ –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —É—Å–ø–µ—Ö–∞ —Å —É–ø—Ä–æ—â–µ–Ω–Ω—ã–º –ø–æ–¥—Ö–æ–¥–æ–º: **80-90%**

–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:

- –ú–∏–Ω–∏–º—É–º –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º –∫–æ–¥–µ
- –ü–æ–Ω—è—Ç–Ω–∞—è –ª–æ–≥–∏–∫–∞
- –ë—ã—Å—Ç—Ä–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
- –õ–µ–≥–∫–æ –æ—Ç–ª–∞–¥–∏—Ç—å
- –ú–æ–∂–Ω–æ –æ—Ç–∫–∞—Ç–∏—Ç—å

–í—ã –ø–æ–ª—É—á–∏—Ç–µ 70-80% –≤—ã–≥–æ–¥—ã –æ—Ç –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–∞–º—è—Ç—å—é, –ø–æ—Ç—Ä–∞—Ç–∏–≤ 10% —É—Å–∏–ª–∏–π. –≠—Ç–æ —Ç–∏–ø–∏—á–Ω—ã–π –ø–æ–¥—Ö–æ–¥ —Ñ–∏–∑–∏–∫–∞ - –ø—Ä–æ—Å—Ç–æ–µ —Ä–µ—à–µ–Ω–∏–µ, –¥–∞—é—â–µ–µ —Ö–æ—Ä–æ—à–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç! üòä

# üìã –î–µ—Ç–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–∞–º—è—Ç—å—é

## –§–∞–∑–∞ 1: –ê–Ω–∞–ª–∏–∑ –∏ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ (2-3 –¥–Ω—è)

### 1.1 –ê—É–¥–∏—Ç —Ç–µ–∫—É—â–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–∞–º—è—Ç–∏### 1.2 –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –º–µ—Å—Ç

```python
# –°–æ–∑–¥–∞–¥–∏–º —Å–∫—Ä–∏–ø—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–∞–º—è—Ç–∏
# analyze_memory_usage.py

import torch
from new_rebuild.config import get_project_config
from new_rebuild.core.moe import MoEProcessor
from new_rebuild.core.cnf import GPUEnhancedCNF
import tracemalloc

def analyze_module_memory(module_name, module_instance, test_input):
    """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏ –º–æ–¥—É–ª–µ–º"""
    tracemalloc.start()

    # Baseline
    baseline = tracemalloc.take_snapshot()

    # –í—ã–ø–æ–ª–Ω—è–µ–º forward pass
    for i in range(100):
        output = module_instance(test_input)

    # Snapshot –ø–æ—Å–ª–µ —Ä–∞–±–æ—Ç—ã
    current = tracemalloc.take_snapshot()

    # –ê–Ω–∞–ª–∏–∑
    top_stats = current.compare_to(baseline, 'lineno')
    print(f"\n=== {module_name} Memory Analysis ===")
    for stat in top_stats[:10]:
        print(stat)

    tracemalloc.stop()
```

### 1.3 –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è

```markdown
# –¢–µ–∫—É—â–µ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏ –≤ –ø—Ä–æ–µ–∫—Ç–µ

## –°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Å —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –ø–∞–º—è—Ç—å—é:

1. **MemoryPoolManager** (`core/lattice/spatial_optimization/memory_manager.py`)

   - –ë–∞–∑–æ–≤—ã–π –ø—É–ª–∏–Ω–≥ —Ç–µ–Ω–∑–æ—Ä–æ–≤
   - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å DeviceManager
   - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

2. **DeviceManager** (`utils/device_manager.py`)

   - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º–∏
   - –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø–∞–º—è—Ç–∏
   - –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –∞–ª–ª–æ–∫–∞—Ü–∏—è

3. **GPU –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã** —Å –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ —Ç–µ–Ω–∑–æ—Ä–∞–º–∏:
   - MoEProcessor
   - GPUEnhancedCNF
   - GPUSpatialProcessor
   - AdaptiveGPUChunker

## –ü—Ä–æ–±–ª–µ–º–Ω—ã–µ –º–µ—Å—Ç–∞:

- –ù–µ—Ç –µ–¥–∏–Ω–æ–≥–æ API –¥–ª—è –≤—Å–µ—Ö –º–æ–¥—É–ª–µ–π
- –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–æ–≥–∏–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–∞–º—è—Ç—å—é
- –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
```

## –§–∞–∑–∞ 2: –ü—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã (2 –¥–Ω—è)

### 2.1 –°–æ–∑–¥–∞–Ω–∏–µ –µ–¥–∏–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞

```python
# new_rebuild/core/memory/unified_memory_manager.py

from abc import ABC, abstractmethod
from typing import Dict, Tuple, Any, Optional, Union
import torch
from dataclasses import dataclass

@dataclass
class TensorRequest:
    """–ó–∞–ø—Ä–æ—Å –Ω–∞ –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Ç–µ–Ω–∑–æ—Ä–∞"""
    shape: Tuple[int, ...]
    dtype: torch.dtype = torch.float32
    category: str = "general"  # general, cell_states, cnf, moe, etc.
    lifetime: str = "temporary"  # temporary, persistent, cached
    priority: int = 0  # 0 - normal, 1 - high, -1 - low

class IMemoryPool(ABC):
    """–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è memory pool"""

    @abstractmethod
    def acquire(self, request: TensorRequest) -> torch.Tensor:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–Ω–∑–æ—Ä –∏–∑ –ø—É–ª–∞"""
        pass

    @abstractmethod
    def release(self, tensor: torch.Tensor) -> None:
        """–í–µ—Ä–Ω—É—Ç—å —Ç–µ–Ω–∑–æ—Ä –≤ –ø—É–ª"""
        pass

    @abstractmethod
    def get_stats(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
        pass
```

### 2.2 –ü—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–µ—Ä–∞—Ä—Ö–∏–∏ –ø—É–ª–æ–≤

```python
# –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—É–ª–æ–≤ –ø–∞–º—è—Ç–∏
MEMORY_POOLS = {
    'cell_states': {
        'sizes': [(32,), (64,), (128,)],  # –†–∞–∑–º–µ—Ä—ã —Å–æ—Å—Ç–æ—è–Ω–∏–π
        'max_tensors': 1000,
        'dtype': torch.float32
    },
    'moe_processing': {
        'sizes': [(100, 32), (500, 32), (1000, 32)],  # Neighbor batches
        'max_tensors': 100,
        'dtype': torch.float32
    },
    'cnf_integration': {
        'sizes': [(10, 32), (50, 32), (100, 32)],  # Trajectory steps
        'max_tensors': 50,
        'dtype': torch.float32
    },
    'spatial_coords': {
        'sizes': [(1000, 3), (5000, 3), (10000, 3)],  # 3D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
        'max_tensors': 20,
        'dtype': torch.int32
    }
}
```

### 2.3 –î–∏–∑–∞–π–Ω —Å–∏—Å—Ç–µ–º—ã –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–≤

```python
@dataclass
class MemoryPriority:
    """–°–∏—Å—Ç–µ–º–∞ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–≤ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–∞–º—è—Ç—å—é"""

    # –ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–≤
    CRITICAL = 2      # –ù–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω
    HIGH = 1          # –û—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ–¥–Ω–∏–º
    NORMAL = 0        # –û–±—ã—á–Ω—ã–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
    LOW = -1          # –û—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç—Å—è –ø–µ—Ä–≤—ã–º

    # –í—Ä–µ–º—è –∂–∏–∑–Ω–∏
    PERSISTENT = "persistent"      # –ñ–∏–≤–µ—Ç –≤–µ—Å—å forward pass
    TEMPORARY = "temporary"        # –ö—Ä–∞—Ç–∫–æ—Å—Ä–æ—á–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
    CACHED = "cached"             # –ú–æ–∂–µ—Ç –±—ã—Ç—å –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω
```

## –§–∞–∑–∞ 3: –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑–æ–≤—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ (3-4 –¥–Ω—è)

### 3.1 –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π Memory Manager

```python
# new_rebuild/core/memory/unified_memory_manager.py

import torch
import torch.nn as nn
from typing import Dict, List, Tuple, Optional, Set
from collections import defaultdict
import threading
import time

class UnifiedMemoryManager(nn.Module):
    """
    –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –ø–∞–º—è—Ç–∏ –¥–ª—è –≤—Å–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞

    –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:
    - –ò–µ—Ä–∞—Ä—Ö–∏—á–µ—Å–∫–∏–µ –ø—É–ª—ã –ø–∞–º—è—Ç–∏
    - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º
    - GPU/CPU –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å
    - –ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    """

    def __init__(self, config: Optional[Dict] = None):
        super().__init__()
        self.config = config or get_project_config()
        self.device_manager = get_device_manager()

        # –ü—É–ª—ã –ø–∞–º—è—Ç–∏ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
        self.pools: Dict[str, MemoryPool] = {}
        self._initialize_pools()

        # Tracking –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç–µ–Ω–∑–æ—Ä–æ–≤
        self.active_tensors: Dict[int, TensorInfo] = {}
        self.tensor_counter = 0

        # Thread safety
        self.lock = threading.RLock()

        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.stats = MemoryStatistics()

    def _initialize_pools(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É–ª–æ–≤ –ø–∞–º—è—Ç–∏"""
        for pool_name, pool_config in MEMORY_POOLS.items():
            self.pools[pool_name] = MemoryPool(
                name=pool_name,
                config=pool_config,
                device=self.device_manager.get_device()
            )

    def acquire_tensor(
        self,
        shape: Tuple[int, ...],
        dtype: torch.dtype = torch.float32,
        category: str = "general",
        lifetime: str = "temporary",
        priority: int = 0
    ) -> torch.Tensor:
        """
        –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–Ω–∑–æ—Ä–∞

        Args:
            shape: –§–æ—Ä–º–∞ —Ç–µ–Ω–∑–æ—Ä–∞
            dtype: –¢–∏–ø –¥–∞–Ω–Ω—ã—Ö
            category: –ö–∞—Ç–µ–≥–æ—Ä–∏—è (cell_states, moe, cnf, etc.)
            lifetime: –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ (temporary, persistent, cached)
            priority: –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç (-1, 0, 1, 2)

        Returns:
            –¢–µ–Ω–∑–æ—Ä –∏–∑ –ø—É–ª–∞ –∏–ª–∏ –Ω–æ–≤—ã–π
        """
        with self.lock:
            request = TensorRequest(
                shape=shape,
                dtype=dtype,
                category=category,
                lifetime=lifetime,
                priority=priority
            )

            # –í—ã–±–∏—Ä–∞–µ–º –ø–æ–¥—Ö–æ–¥—è—â–∏–π –ø—É–ª
            pool = self._select_pool(request)

            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–Ω–∑–æ—Ä
            tensor = pool.acquire(request)

            # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º
            tensor_id = self._register_tensor(tensor, request)

            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            self.stats.record_acquisition(request, tensor_id)

            return tensor

    def release_tensor(self, tensor: torch.Tensor):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–Ω–∑–æ—Ä –≤ –ø—É–ª"""
        with self.lock:
            tensor_id = id(tensor)

            if tensor_id not in self.active_tensors:
                return  # –ù–µ –Ω–∞—à —Ç–µ–Ω–∑–æ—Ä

            info = self.active_tensors[tensor_id]
            pool = self.pools.get(info.category)

            if pool:
                pool.release(tensor)

            # –£–¥–∞–ª—è–µ–º –∏–∑ tracking
            del self.active_tensors[tensor_id]

            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            self.stats.record_release(info)
```

### 3.2 –°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø—É–ª—ã

```python
# new_rebuild/core/memory/specialized_pools.py

class CellStatePool(MemoryPool):
    """–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—É–ª –¥–ª—è —Å–æ—Å—Ç–æ—è–Ω–∏–π –∫–ª–µ—Ç–æ–∫"""

    def __init__(self, state_size: int, max_cells: int = 10000):
        super().__init__(
            name="cell_states",
            config={
                'sizes': [(state_size,), (10, state_size), (100, state_size)],
                'max_tensors': max_cells // 10,
                'dtype': torch.float32
            }
        )

        # –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∞–ª–ª–æ–∫–∞—Ü–∏—è –¥–ª—è —á–∞—Å—Ç—ã—Ö —Ä–∞–∑–º–µ—Ä–æ–≤
        self._preallocate_common_sizes()

    def _preallocate_common_sizes(self):
        """–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –≤—ã–¥–µ–ª—è–µ–º –ø–∞–º—è—Ç—å –¥–ª—è —á–∞—Å—Ç—ã—Ö —Ä–∞–∑–º–µ—Ä–æ–≤"""
        common_batch_sizes = [1, 10, 100, 1000]

        for batch_size in common_batch_sizes:
            shape = (batch_size, self.config['sizes'][0][0])
            for _ in range(5):  # 5 —Ç–µ–Ω–∑–æ—Ä–æ–≤ –∫–∞–∂–¥–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
                tensor = torch.empty(shape, dtype=self.dtype, device=self.device)
                self.available_tensors[shape].append(tensor)

class MoEProcessingPool(MemoryPool):
    """–ü—É–ª –¥–ª—è MoE –æ–±—Ä–∞–±–æ—Ç–∫–∏"""

    def __init__(self, state_size: int, max_neighbors: int):
        super().__init__(
            name="moe_processing",
            config={
                'sizes': [
                    (max_neighbors, state_size),
                    (max_neighbors // 2, state_size),
                    (max_neighbors // 10, state_size)
                ],
                'max_tensors': 50,
                'dtype': torch.float32
            }
        )
```

### 3.3 –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Å–ª–æ–π

```python
# new_rebuild/core/memory/integration.py

class MemoryManagedModule(nn.Module):
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –º–æ–¥—É–ª–µ–π —Å —É–ø—Ä–∞–≤–ª—è–µ–º–æ–π –ø–∞–º—è—Ç—å—é"""

    def __init__(self):
        super().__init__()
        self.memory_manager = get_unified_memory_manager()
        self.allocated_tensors: List[torch.Tensor] = []

    def allocate(
        self,
        shape: Tuple[int, ...],
        **kwargs
    ) -> torch.Tensor:
        """–£–¥–æ–±–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –∞–ª–ª–æ–∫–∞—Ü–∏–∏"""
        tensor = self.memory_manager.acquire_tensor(
            shape=shape,
            category=self._get_category(),
            **kwargs
        )
        self.allocated_tensors.append(tensor)
        return tensor

    def cleanup(self):
        """–û—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –≤—Å–µ—Ö —Ç–µ–Ω–∑–æ—Ä–æ–≤"""
        for tensor in self.allocated_tensors:
            self.memory_manager.release_tensor(tensor)
        self.allocated_tensors.clear()

    def _get_category(self) -> str:
        """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏—é –º–æ–¥—É–ª—è"""
        class_name = self.__class__.__name__.lower()
        if 'moe' in class_name:
            return 'moe_processing'
        elif 'cnf' in class_name:
            return 'cnf_integration'
        elif 'cell' in class_name:
            return 'cell_states'
        else:
            return 'general'
```

## –§–∞–∑–∞ 4: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –∫–æ–¥–æ–º (3-4 –¥–Ω—è)

### 4.1 –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ MoE Processor

```python
# –û–±–Ω–æ–≤–ª—è–µ–º new_rebuild/core/moe/moe_processor.py

class MoEProcessor(MemoryManagedModule):  # –ù–∞—Å–ª–µ–¥—É–µ–º –æ—Ç –Ω–æ–≤–æ–≥–æ –±–∞–∑–æ–≤–æ–≥–æ –∫–ª–∞—Å—Å–∞

    def forward_single_cell(self, cell_idx: int, ...):
        # –í–º–µ—Å—Ç–æ –ø—Ä—è–º–æ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ–Ω–∑–æ—Ä–æ–≤
        # distant_output = torch.zeros((1, self.state_size))

        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–ø—Ä–∞–≤–ª—è–µ–º—É—é –ø–∞–º—è—Ç—å
        distant_output = self.allocate(
            shape=(1, self.state_size),
            lifetime="temporary",
            priority=MemoryPriority.NORMAL
        )

        # –í –∫–æ–Ω—Ü–µ –Ω–µ –∑–∞–±—ã–≤–∞–µ–º cleanup
        self.cleanup()
```

### 4.2 –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ CNF –º–æ–¥—É–ª–µ–π

```python
# –û–±–Ω–æ–≤–ª—è–µ–º new_rebuild/core/cnf/gpu_enhanced_cnf.py

class GPUEnhancedCNF(MemoryManagedModule):

    def __init__(self, ...):
        super().__init__()
        # ... existing init ...

        # –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∞–ª–ª–æ–∫–∞—Ü–∏—è –¥–ª—è trajectory
        self.trajectory_pool = self.memory_manager.acquire_tensor(
            shape=(self.max_batch_size, self.integration_steps, self.state_size),
            category="cnf_integration",
            lifetime="cached",  # –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º
            priority=MemoryPriority.HIGH
        )
```

### 4.3 –°–æ–∑–¥–∞–Ω–∏–µ –∞–¥–∞–ø—Ç–µ—Ä–æ–≤ –¥–ª—è legacy –∫–æ–¥–∞

```python
# new_rebuild/core/memory/legacy_adapter.py

class LegacyMemoryAdapter:
    """–ê–¥–∞–ø—Ç–µ—Ä –¥–ª—è –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ–π –º–∏–≥—Ä–∞—Ü–∏–∏ legacy –∫–æ–¥–∞"""

    def __init__(self):
        self.memory_manager = get_unified_memory_manager()

    def get_tensor(self, shape: Tuple[int, ...], dtype=torch.float32):
        """Legacy —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π –º–µ—Ç–æ–¥"""
        return self.memory_manager.acquire_tensor(
            shape=shape,
            dtype=dtype,
            category="legacy",
            lifetime="temporary"
        )

    def return_tensor(self, tensor: torch.Tensor):
        """Legacy —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π –º–µ—Ç–æ–¥"""
        self.memory_manager.release_tensor(tensor)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π –∞–¥–∞–ø—Ç–µ—Ä –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
legacy_memory_pool = LegacyMemoryAdapter()
```

## –§–∞–∑–∞ 5: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ (2-3 –¥–Ω—è)

### 5.1 –°–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞

```python
# new_rebuild/core/memory/monitoring.py

class MemoryMonitor:
    """–†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø–∞–º—è—Ç–∏"""

    def __init__(self):
        self.metrics = defaultdict(lambda: defaultdict(float))
        self.alerts = []

    def track_allocation(self, category: str, size_mb: float):
        """–û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –∞–ª–ª–æ–∫–∞—Ü–∏–π"""
        self.metrics[category]['total_allocated_mb'] += size_mb
        self.metrics[category]['allocation_count'] += 1
        self.metrics[category]['peak_mb'] = max(
            self.metrics[category]['peak_mb'],
            self.metrics[category]['current_mb'] + size_mb
        )
        self.metrics[category]['current_mb'] += size_mb

    def check_memory_pressure(self) -> float:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–≤–ª–µ–Ω–∏—è –Ω–∞ –ø–∞–º—è—Ç—å (0.0 - 1.0)"""
        if torch.cuda.is_available():
            allocated = torch.cuda.memory_allocated() / 1024**3
            reserved = torch.cuda.memory_reserved() / 1024**3
            total = torch.cuda.get_device_properties(0).total_memory / 1024**3

            pressure = allocated / total

            if pressure > 0.9:
                self.alerts.append({
                    'level': 'critical',
                    'message': f'Memory pressure critical: {pressure:.1%}',
                    'timestamp': time.time()
                })

            return pressure
        else:
            # CPU memory check
            import psutil
            return psutil.virtual_memory().percent / 100

    def generate_report(self) -> Dict[str, Any]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç—á–µ—Ç–∞ –æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –ø–∞–º—è—Ç–∏"""
        report = {
            'summary': {
                'total_allocated_mb': sum(
                    m['total_allocated_mb'] for m in self.metrics.values()
                ),
                'total_allocations': sum(
                    m['allocation_count'] for m in self.metrics.values()
                ),
                'memory_pressure': self.check_memory_pressure()
            },
            'by_category': dict(self.metrics),
            'alerts': self.alerts[-10:]  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 –∞–ª–µ—Ä—Ç–æ–≤
        }

        return report
```

### 5.2 –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è

```python
# new_rebuild/core/memory/optimizer.py

class MemoryOptimizer:
    """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–∞–º—è—Ç–∏"""

    def __init__(self, memory_manager: UnifiedMemoryManager):
        self.memory_manager = memory_manager
        self.optimization_history = []

    def optimize(self):
        """–ó–∞–ø—É—Å–∫ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏"""
        pressure = self.memory_manager.monitor.check_memory_pressure()

        if pressure > 0.8:
            self._emergency_cleanup()
        elif pressure > 0.6:
            self._moderate_cleanup()

        self._rebalance_pools()
        self._compact_memory()

    def _emergency_cleanup(self):
        """–≠–∫—Å—Ç—Ä–µ–Ω–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–º –¥–∞–≤–ª–µ–Ω–∏–∏"""
        logger.warning("üö® Emergency memory cleanup triggered!")

        # –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –≤—Å–µ low-priority —Ç–µ–Ω–∑–æ—Ä—ã
        for pool in self.memory_manager.pools.values():
            pool.release_low_priority()

        # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π GC
        import gc
        gc.collect()

        if torch.cuda.is_available():
            torch.cuda.empty_cache()

    def _rebalance_pools(self):
        """–ü–µ—Ä–µ–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∞ –ø–∞–º—è—Ç–∏ –º–µ–∂–¥—É –ø—É–ª–∞–º–∏"""
        stats = self.memory_manager.get_pool_statistics()

        # –ù–∞—Ö–æ–¥–∏–º –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –∏ –Ω–µ–¥–æ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –ø—É–ª—ã
        overused = []
        underused = []

        for pool_name, pool_stats in stats.items():
            usage = pool_stats['usage_ratio']
            if usage > 0.9:
                overused.append(pool_name)
            elif usage < 0.3:
                underused.append(pool_name)

        # –ü–µ—Ä–µ—Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –ª–∏–º–∏—Ç—ã
        if overused and underused:
            self._redistribute_limits(overused, underused)
```

### 5.3 –ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ

```python
# new_rebuild/core/memory/profiler.py

class MemoryProfiler:
    """–ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤—â–∏–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–∞–º—è—Ç–∏"""

    def __init__(self):
        self.profiles = []
        self.current_profile = None

    @contextmanager
    def profile(self, name: str):
        """–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏—è"""
        profile = {
            'name': name,
            'start_time': time.time(),
            'start_memory': self._get_current_memory(),
            'allocations': []
        }

        self.current_profile = profile

        try:
            yield
        finally:
            profile['end_time'] = time.time()
            profile['end_memory'] = self._get_current_memory()
            profile['duration_ms'] = (profile['end_time'] - profile['start_time']) * 1000
            profile['memory_delta_mb'] = (
                profile['end_memory'] - profile['start_memory']
            ) / (1024**2)

            self.profiles.append(profile)
            self.current_profile = None

    def get_top_memory_users(self, n: int = 10) -> List[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–æ–ø N –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–µ–π –ø–∞–º—è—Ç–∏"""
        sorted_profiles = sorted(
            self.profiles,
            key=lambda p: p['memory_delta_mb'],
            reverse=True
        )
        return sorted_profiles[:n]
```

## –§–∞–∑–∞ 6: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è (2 –¥–Ω—è)

### 6.1 Unit —Ç–µ—Å—Ç—ã

```python
# tests/test_unified_memory_manager.py

import pytest
import torch
from new_rebuild.core.memory import UnifiedMemoryManager

class TestUnifiedMemoryManager:

    def test_basic_allocation(self):
        """–¢–µ—Å—Ç –±–∞–∑–æ–≤–æ–π –∞–ª–ª–æ–∫–∞—Ü–∏–∏"""
        manager = UnifiedMemoryManager()

        tensor = manager.acquire_tensor(
            shape=(100, 32),
            category="test"
        )

        assert tensor.shape == (100, 32)
        assert tensor.device == manager.device_manager.get_device()

        manager.release_tensor(tensor)

    def test_pool_reuse(self):
        """–¢–µ—Å—Ç –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ç–µ–Ω–∑–æ—Ä–æ–≤"""
        manager = UnifiedMemoryManager()

        # –ü–µ—Ä–≤–∞—è –∞–ª–ª–æ–∫–∞—Ü–∏—è
        tensor1 = manager.acquire_tensor(shape=(100, 32))
        tensor1_id = id(tensor1)
        manager.release_tensor(tensor1)

        # –í—Ç–æ—Ä–∞—è –∞–ª–ª–æ–∫–∞—Ü–∏—è —Ç–æ–≥–æ –∂–µ —Ä–∞–∑–º–µ—Ä–∞
        tensor2 = manager.acquire_tensor(shape=(100, 32))
        tensor2_id = id(tensor2)

        # –î–æ–ª–∂–Ω—ã –ø–æ–ª—É—á–∏—Ç—å —Ç–æ—Ç –∂–µ —Ç–µ–Ω–∑–æ—Ä –∏–∑ –ø—É–ª–∞
        assert tensor1_id == tensor2_id

    def test_memory_pressure(self):
        """–¢–µ—Å—Ç –ø–æ–≤–µ–¥–µ–Ω–∏—è –ø—Ä–∏ –Ω–µ—Ö–≤–∞—Ç–∫–µ –ø–∞–º—è—Ç–∏"""
        manager = UnifiedMemoryManager()

        # –ê–ª–ª–æ—Ü–∏—Ä—É–µ–º –º–Ω–æ–≥–æ –ø–∞–º—è—Ç–∏
        tensors = []
        for i in range(100):
            t = manager.acquire_tensor(
                shape=(1000, 1000),
                priority=-1  # Low priority
            )
            tensors.append(t)

        # –ü—Ä–∏ –≤—ã—Å–æ–∫–æ–º –¥–∞–≤–ª–µ–Ω–∏–∏ –¥–æ–ª–∂–Ω–∞ —Å—Ä–∞–±–æ—Ç–∞—Ç—å –æ—á–∏—Å—Ç–∫–∞
        stats = manager.get_stats()
        assert stats['cleanups_triggered'] > 0
```

### 6.2 Integration —Ç–µ—Å—Ç—ã

```python
# tests/test_memory_integration.py

def test_moe_memory_integration():
    """–¢–µ—Å—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å MoE"""
    from new_rebuild.core.moe import MoEProcessor

    processor = MoEProcessor(state_size=32)

    # –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É
    for i in range(100):
        output = processor.forward_single_cell(
            cell_idx=i,
            current_state=torch.randn(1, 32),
            neighbor_states=torch.randn(10, 32),
            neighbor_indices=torch.arange(10)
        )

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–∞–º—è—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç—Å—è
    memory_stats = processor.memory_manager.get_stats()
    assert memory_stats['active_tensors'] == 0
```

### 6.3 –ë–µ–Ω—á–º–∞—Ä–∫–∏

```python
# benchmarks/memory_benchmark.py

def benchmark_memory_performance():
    """–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —Å/–±–µ–∑ memory manager"""

    results = {
        'with_memory_manager': [],
        'without_memory_manager': []
    }

    # –¢–µ—Å—Ç —Å memory manager
    manager = UnifiedMemoryManager()
    start = time.time()

    for _ in range(1000):
        tensor = manager.acquire_tensor((1000, 32))
        # –°–∏–º—É–ª—è—Ü–∏—è —Ä–∞–±–æ—Ç—ã
        result = tensor @ tensor.T
        manager.release_tensor(tensor)

    results['with_memory_manager'] = time.time() - start

    # –¢–µ—Å—Ç –±–µ–∑ memory manager
    start = time.time()

    for _ in range(1000):
        tensor = torch.zeros((1000, 32))
        result = tensor @ tensor.T
        del tensor

    results['without_memory_manager'] = time.time() - start

    print(f"Performance improvement: {
        results['without_memory_manager'] / results['with_memory_manager']
    }x")
```

## –§–∞–∑–∞ 7: –†–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è (1-2 –¥–Ω—è)

### 7.1 –ú–∏–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π –ø–ª–∞–Ω

```markdown
# –ü–ª–∞–Ω –º–∏–≥—Ä–∞—Ü–∏–∏ –Ω–∞ UnifiedMemoryManager

## –≠—Ç–∞–ø 1: –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ (–Ω–µ–¥–µ–ª—è 1)

- [ ] –†–∞–∑–≤–µ—Ä–Ω—É—Ç—å UnifiedMemoryManager –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π –≤–µ—Ç–∫–µ
- [ ] –ó–∞–ø—É—Å—Ç–∏—Ç—å —Ç–µ—Å—Ç—ã —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
- [ ] –ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è

## –≠—Ç–∞–ø 2: –ü–∏–ª–æ—Ç–Ω–∞—è –º–∏–≥—Ä–∞—Ü–∏—è (–Ω–µ–¥–µ–ª—è 2)

- [ ] –ú–∏–≥—Ä–∏—Ä–æ–≤–∞—Ç—å MoEProcessor
- [ ] –ú–∏–≥—Ä–∏—Ä–æ–≤–∞—Ç—å GPUEnhancedCNF
- [ ] –ò–∑–º–µ—Ä–∏—Ç—å –≤–ª–∏—è–Ω–∏–µ –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

## –≠—Ç–∞–ø 3: –ü–æ–ª–Ω–∞—è –º–∏–≥—Ä–∞—Ü–∏—è (–Ω–µ–¥–µ–ª–∏ 3-4)

- [ ] –ú–∏–≥—Ä–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –º–æ–¥—É–ª–∏
- [ ] –£–¥–∞–ª–∏—Ç—å legacy –∫–æ–¥
- [ ] –û–±–Ω–æ–≤–∏—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é
```

### 7.2 –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è

```python
# new_rebuild/config/memory_config.py

@dataclass
class UnifiedMemoryConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è UnifiedMemoryManager"""

    # –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    enabled: bool = True
    debug_mode: bool = False

    # –†–∞–∑–º–µ—Ä—ã –ø—É–ª–æ–≤ (–≤ –ú–ë)
    pool_sizes: Dict[str, float] = field(default_factory=lambda: {
        'cell_states': 1000.0,
        'moe_processing': 500.0,
        'cnf_integration': 300.0,
        'spatial_coords': 200.0,
        'general': 1000.0
    })

    # –ü–æ–ª–∏—Ç–∏–∫–∏ –æ—á–∏—Å—Ç–∫–∏
    cleanup_threshold: float = 0.8  # –ü—Ä–∏ 80% –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    emergency_threshold: float = 0.95  # –≠–∫—Å—Ç—Ä–µ–Ω–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞

    # –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
    enable_profiling: bool = True
    profile_interval_seconds: int = 60

    # –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
    enable_auto_optimization: bool = True
    optimization_interval_seconds: int = 300
```

### 7.3 –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è API

```python
"""
UnifiedMemoryManager API Reference
==================================

Basic Usage:
-----------
from new_rebuild.core.memory import get_unified_memory_manager

# –ü–æ–ª—É—á–∏—Ç—å –º–µ–Ω–µ–¥–∂–µ—Ä (singleton)
memory_manager = get_unified_memory_manager()

# –í—ã–¥–µ–ª–∏—Ç—å —Ç–µ–Ω–∑–æ—Ä
tensor = memory_manager.acquire_tensor(
    shape=(100, 32),
    dtype=torch.float32,
    category="my_module",  # –ö–∞—Ç–µ–≥–æ—Ä–∏—è –¥–ª—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏
    lifetime="temporary",  # temporary/persistent/cached
    priority=0  # -1 (low) to 2 (critical)
)

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–µ–Ω–∑–æ—Ä
result = some_computation(tensor)

# –í–µ—Ä–Ω—É—Ç—å –≤ –ø—É–ª
memory_manager.release_tensor(tensor)

Context Manager:
---------------
with memory_manager.allocate_context() as ctx:
    tensor1 = ctx.allocate((100, 32))
    tensor2 = ctx.allocate((50, 64))
    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ

Statistics:
----------
stats = memory_manager.get_stats()
print(f"Total allocated: {stats['total_allocated_mb']}MB")
print(f"Pool efficiency: {stats['pool_hit_rate']:.1%}")
"""
```

## –ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞

–ü–æ—Å–ª–µ –≤–Ω–µ–¥—Ä–µ–Ω–∏—è UnifiedMemoryManager –æ–∂–∏–¥–∞–µ–º:

1. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: +15-30% —Å–∫–æ—Ä–æ—Å—Ç—å forward pass
2. **–ü–∞–º—è—Ç—å**: -30-50% –ø–∏–∫–æ–≤–æ–µ –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ
3. **–°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å**: -90% OOM –æ—à–∏–±–æ–∫
4. **–ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å**: 2-3x –±–æ–ª—å—à–µ —Ä–∞–∑–º–µ—Ä —Ä–µ—à–µ—Ç–æ–∫

## –†–∏—Å–∫–∏ –∏ –º–∏—Ç–∏–≥–∞—Ü–∏—è

1. **–†–∏—Å–∫**: –°–ª–æ–∂–Ω–æ—Å—Ç—å –º–∏–≥—Ä–∞—Ü–∏–∏ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∫–æ–¥–∞

   - **–ú–∏—Ç–∏–≥–∞—Ü–∏—è**: –ü–æ—ç—Ç–∞–ø–Ω–∞—è –º–∏–≥—Ä–∞—Ü–∏—è —Å legacy –∞–¥–∞–ø—Ç–µ—Ä–∞–º–∏

2. **–†–∏—Å–∫**: Overhead –æ—Ç —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–∞–º—è—Ç—å—é

   - **–ú–∏—Ç–∏–≥–∞—Ü–∏—è**: –ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è hot paths

3. **–†–∏—Å–∫**: –ù–µ—Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å –Ω–µ–∫–æ—Ç–æ—Ä—ã–º–∏ PyTorch –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏
   - **–ú–∏—Ç–∏–≥–∞—Ü–∏—è**: Fallback –º–µ—Ö–∞–Ω–∏–∑–º—ã –¥–ª—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
