План реализации: Архитектура на основе локальных правил и эмерджентной связности
Цель: Перестроить архитектуру Lattice3D для поддержки динамической, самоорганизующейся топологии, основанной на биологически правдоподобных локальных правилах, с жестким ограничением на использование VRAM одной GPU.
Фаза 1: Фундаментальная перестройка топологии и введение весовых коэффициентов
Задача: Заменить текущую монолитную стратегию поиска соседей на многоуровневую систему и ввести механизм динамических весов для связей.
Шаг 1.1: Создание модуля Spatial Hashing (Новый файл)
Действие: Создать новый файл core/lattice_3d/spatial_hashing.py.
Примечание: Это оправданное создание нового файла, так как оно инкапсулирует сложную, переиспользуемую логику, что соответствует принципам хорошей архитектуры.
Содержимое:
Класс MortonEncoder: Реализует 3D -> 1D кодирование координат для улучшения cache locality.
Класс SpatialHashGrid:
**init**(dimensions, grid_cell_size): Инициализирует хэш-решетку.
insert(coords, cell_index): Добавляет клетку в решетку.
query_radius(coords, radius): Эффективно находит всех соседей в заданном радиусе, проверяя только смежные ячейки хэш-решетки.
Шаг 1.2: Рефакторинг NeighborTopology и Lattice3D (core/lattice_3d/main.py)
Создание новой TieredStrategy:
В NeighborTopology добавить новую стратегию "tiered".
При выборе этой стратегии get_neighbors будет выполнять 3 этапа:
Уровень 1 (70%): Локальные соседи. Получить соседей из SpatialHashGrid в небольшом радиусе.
Уровень 2 (20%): Функциональные соседи. Временно реализуем как случайную выборку из всей решетки (как сейчас random_sample). Это будет заделом для будущих, более умных методов.
Уровень 3 (10%): Стохастические дальние связи. Реализовать простое правило: выбрать несколько случайных клеток, где вероятность выбора обратно пропорциональна евклидову расстоянию (чтобы имитировать Levy flight).
Интеграция весов связей в Lattice3D:
Добавить в Lattice3D.**init** новый буфер (не параметр модели): self.register_buffer('connection_weights', torch.ones(...)).
Размерность этого тензора будет (total_cells, max_neighbors).
В Lattice3D.forward при сборе состояний соседей также собирать соответствующие им веса из self.connection_weights.
Обновление LatticeConfig:
Добавить neighbor_strategy_config для "tiered", где можно будет указать проценты и радиусы.
Шаг 1.3: Адаптация клетки GatedMLPCell (core/cell_prototype/architectures/gmlp_cell.py)
Действие: Модифицировать сигнатуру GatedMLPCell.forward.
Было: forward(self, neighbor_states, own_state, ...)
Станет: forward(self, neighbor_states, own_state, connection_weights, ...)
Логика: Внутри forward, перед основной обработкой, входящие состояния соседей будут умножаться на их веса: weighted_neighbor_states = neighbor_states \* connection_weights.unsqueeze(-1).
Ожидаемый результат Фазы 1: Полностью рабочая, но еще не обучаемая система связей. Топология строится по новым правилам, и каждая связь имеет вес, который влияет на взаимодействие клеток.
Фаза 2: Реализация синаптической пластичности (STDP)
Задача: "Оживить" веса связей, заставив их изменяться в соответствии с активностью клеток.
Шаг 2.1: Модификация Lattice3D (core/lattice_3d/main.py)
Отслеживание предыдущих состояний:
В Lattice3D добавить еще один буфер self.register_buffer('previous_states', torch.zeros(...)).
В конце каждого вызова forward, копировать self.states в self.previous_states.
Создание метода apply_stdp_update:
Этот метод будет вызываться в конце forward.
Логика:
Определить "активные" клетки (например, где значение состояния превышает некий порог activity_threshold).
Для каждой связи "клетка А -> клетка Б" сравнить их активность в previous_states и states.
Реализовать простое правило STDP:
Если клетка-сосед А была активна на шаге t-1, а клетка Б стала активной на шаге t, увеличить вес связи (LTP - Long-Term Potentiation).
Если клетка Б была активна на шаге t-1, а сосед А стал активен на шаге t, уменьшить вес связи (LTD - Long-Term Depression).
Применить вычисленные delta_w к self.connection_weights и ограничить веса (например, в диапазоне [0.1, 2.0]).
Шаг 2.2: Обновление конфигурации (LatticeConfig и YAML-файлы)
Действие: Добавить в LatticeConfig параметры для управления STDP:
enable_plasticity: bool
plasticity_rule: str (например, "stdp")
stdp_config:
learning_rate: float
activity_threshold: float
Ожидаемый результат Фазы 2: Сеть, в которой связи динамически усиливаются и ослабляются, формируя паттерны и "пути" прохождения сигналов. Это первый шаг к настоящей самоорганизации.
Фаза 3: Продвинутая адаптация и специализация
Задача: Внедрить более сложные механизмы для стабилизации обучения и функциональной специализации кластеров.
Шаг 3.1: Конкурентное обучение по Хеббу
Действие: Модифицировать apply_stdp_update.
Логика: После вычисления delta_w для всех входящих связей клетки, нормализовать их так, чтобы сумма весов оставалась постоянной. Это заставит связи "конкурировать" друг с другом, предотвращая "убегание" всех весов к максимуму.
Шаг 3.2: Метапластичность (BCM правило)
Действие: Усложнить правило STDP.
Логика: Порог activity_threshold для LTP/LTD не должен быть фиксированным. Он должен плавно меняться в зависимости от средней недавней активности самой клетки. Это стабилизирует обучение и предотвращает насыщение.
Шаг 3.3: Исследование динамической топологии (Growing Neural Gas)
Действие: Это отдельная, крупная исследовательская задача.
Логика: Разработать механизм, который периодически не только обновляет веса, но и может полностью перестраивать граф связей: добавлять/удалять узлы (клетки) и ребра (связи) на основе статистики их использования.
Ожидаемый результат Фазы 3: Высокоадаптивная сеть, способная к функциональной специализации и формированию сложных, иерархических структур — максимально приближенная к биологическому прототипу.
